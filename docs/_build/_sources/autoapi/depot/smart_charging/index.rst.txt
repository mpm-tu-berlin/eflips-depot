:py:mod:`depot.smart_charging`
==============================

.. py:module:: depot.smart_charging

.. autoapi-nested-parse::

   Smart charging algorithm.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   depot.smart_charging.SmartCharging
   depot.smart_charging.ControlSmartCharging




.. py:class:: SmartCharging(data, start_date, price_data_path, power_limit_grid)


   Class which implements the smart charging algorithm for depot charged vehicles of Lauth, Mundt,
   Göhlich.
   In the eflips_setiings [depot][log_cm_data] has to be True

   .. py:method:: add_power_limit_grid_to_power(data)


   .. py:method:: schedule_method(ev)

      Iterates over the process list. And generates the Precon and normal schedule
      :param ev: has to be type DepotEvaluation
      :return: prober schedule and a schdule with all incomplet depot stays


   .. py:method:: calc_charging_time(start, end)

      :param start: a list of all start times
      :param end: a list of all end times
      :return: total duration of charging


   .. py:method:: set_power(power)

      :param power: a pd_frame


   .. py:method:: max_simulation_time()

      :return: The maximum time.


   .. py:method:: construct_pd_frame_charging_history_energy()

      :return: empty pd Frame with time as index and bus stops in depot as columns


   .. py:method:: construct_empty_dict_charging_log()

      :return: a dict, in which al the charging intervalles of the vehicles will be stored


   .. py:method:: smart_charging_algorithm()

      needs self.schedule, self.power_price (start_time, end_time, price), power_limi_grid. Implements the algorithm of Lauth, Mundt,
      Göhlich.
      :return: False if smart charging is not possible, a pd Frame with the time intervalls and the charging power, if smart charging was possible


   .. py:method:: energy_calculation_smart(start_time, end_time, row_bus, row_power, ID_power, power_rest, ID_bus)

      For outsource some of the stuff of smart_charging_algorithm
      :param start_time:
      :param end_time:
      :param row_bus:
      :param ID_power:
      :param power_rest:
      :return:


   .. py:method:: smart_charging_algorithm_even()

      Same power curve, just buses will always be charged.


   .. py:method:: energy_calculation_smart_even(start_time, end_time, row_bus, row_power, ID_power, ID_bus, constant_power)


   .. py:method:: smart_even_upscalinig(scaling_quotients, ID_power)

      Scales the power for a specific intervall by scaling quotinet up. Also starts the proces to substract the power from an other power intervall.


   .. py:method:: substract_power_most_expensive(power, ID_bus, ID_power)

      Substracts the power from an other power intervall.


   .. py:method:: smart_even_downscalinig(scaling_quotients, ID_power)

      Scales the power for a specific intervall by scaling quotinet down. Also starts the proces to add the power from an other power intervall.


   .. py:method:: add_power_less_expensive(power, ID_bus, ID_power)


   .. py:method:: immediately_charging()

      Charges the buses immediatley after the parked. No charging eqauation steps.
      :return: pd Frame


   .. py:method:: energy_calculation_immediately(start_time, end_time, row_bus, row_power, ID_power, ID_bus)

      Helper
      :param start_time:
      :param end_time:
      :param row_bus:
      :param row_power:
      :param ID_power:
      :return:


   .. py:method:: intersection(interval_a, interval_b)

      :param interval_a: list of two numbers
      :param interval_b: list of two numbers
      :return: the intersection of the two intervalls or False if no intersection is there


   .. py:method:: in_period(interval, time)

      Checks if time is in interval.


   .. py:method:: compensate_to_energy_real(energy_delta, ID_bus, row_bus, charging_log, type_of_power)

      Makes the correct adjustments, so charg_eqaution_steps can be implemented.
      :param energy_delta: differnce between energy and energy_real
      :param ID_bus:
      :param row_bus:
      :param charging_log: the charging log the function should use
      type_of_power: "used_power_smart" or "used_power_immediately"
      :return:


   .. py:method:: precondition()

      Writes only the power in the power DF not in the charging logs. Writes the power always in all three charging type columns


   .. py:method:: plot_results(language='eng')

      Plots the results
      :return:


   .. py:method:: plot_charging_intervalls_smart()


   .. py:method:: plot_charging_intervalls_smart_even()


   .. py:method:: plot_charging_intervalls(dict_charging_logs)

      Plots a figure, where you can see the stress of the battries.
      :return:


   .. py:method:: results()

      Calculates some results and prints them.
      :return:


   .. py:method:: period_of_use(type)

      Calculates the time [minutes] which the grid infrastructure is used.
      :param type:
      :return:


   .. py:method:: export_for_vehicle_periods_smart()


   .. py:method:: export_for_vehicle_periods_smart_even()


   .. py:method:: export_for_vehicle_periods(dict_charging_logs)

      Brings the data to an format, evalutatio.DepotEvaluation.vehicle_periods can work with.


   .. py:method:: validation()

      Validates some values, and prints weired occurrences, which might be checked by the user



.. py:class:: ControlSmartCharging(data, start_date, price_data_path, power_limit_grid=0, charging_efficiency=1)


   Some control units for the Smart Charging class. Does multiple runs with the same basic settings.

   .. py:method:: lowest_power(accuracy)

      Uses as the first upper boundary the max power of immediately charging, if no power_limit_grid is given, only works if the power_limit_grid is an int
      :param accuracy: in percent
      :return: results of the last succesful power run, power_lower_boundary and power_upper_boundary



