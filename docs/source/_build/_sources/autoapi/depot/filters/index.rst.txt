:py:mod:`depot.filters`
=======================

.. py:module:: depot.filters


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   depot.filters.VehicleFilter




.. py:class:: VehicleFilter(filter_names=None, **kwargs)


   Class to build and apply filters for vehicles. Designed to work with
   simpy FilterStore and subclasses in the depot simulation: Implements
   __call__ to make an instance directly callable and return the all()-result
   of the criteria. Can be recalled. Usable e.g. for simpyExt.FilterStoreExt
   that needs the store item as single positional argument for the filter
   function. Filter criteria are prepared in class methods and can be selected
   and combined before application.

   Parameters:
   filter_names: [list or None] of filter method names (as strings, 'filter_'
       omitted) of this class that should be applied on a vehicle. If left
       None, the VehicleFilter returns True.
   All other parameters that are required by selected filter methods must be
       added as keyword arguments during init (see method descriptions).

   Attributes:
   filters: [list] of one or more VehicleFilter.filter_... methods or other
       valid callables. Filled automatically from *filter_names*. Can be None
       or empty, in which case the VehicleFilter returns True. Entries can be
       added during definition (see filter_names) and afterwards (see
       VehicleFilter.append).

   Usage:
       Instantiate a VehicleFilter object. Pass arguments required for the
       checks, such as filter_names upon instantiation as kwargs or add them
       later.
       Example:
           vf = VehicleFilter(filter_names=['service_need'], env=env)
           trueorfalse = vf(vehicle)
       Static methods may be called without instantiation. Example:
           trueorfalse = VehicleFilter.filter_no_active_processes(vehicle)

   When adding a new filter method:
   - The method name must be preceeded by 'filter_'.
   - 'vehicle' must be the only method parameter. Additional parameters can be
       accessed via the VehicleFilter object attributes. Passing all those
       parameters as keyword arguments during init adds them automatically as
       attribute of the VehicleFilter. Alternatively, attributes might be
       added after init, before calling the filter.


   .. py:method:: __call__(vehicle)

      Method that actually applies filters. Return True if all of
      self.filter return True or self.filters is empty.


   .. py:method:: any(vehicle)

      Return True if any of the filters in self.filters is True or
      self.filters is empty. Optional method in addition to the standard
      usage with logical all which is implemented in __call__.


   .. py:method:: filters_from_names()

      Append references to methods specified in filter_names to
      self.filters. Extends the given strings by 'filter_' at the beginning,
      so that part does not have to be passed during instantiation.
      Filters can alternatively be added after instantiation using append().


   .. py:method:: append(filter)

      Append *filter* to self.filters. Filter must be a callable accepting
      vehicle as argument and returning a boolean value.


   .. py:method:: filter_vehicle_type(vehicle)

      Return True if the vehicle type matches ANY item in
      self.vehicle_types.

      Attributes required in self:
      vehicle_types: [list] of eflips.depot.simple_vehicle.VehicleType
          objects


   .. py:method:: get_vt_objects(force=False)

      Helper for filter methods using self.vehicle_types. Get objects for
      strings in self.vehicle_types.
      If *force* is False and self.vehicle_types_converted is True, the
      conversion is skipped (useful for reusing the filter object with the
      same parameters). If *force* is true, the conversion is done even if
      self.vehicle_types_converted is True (useful for reusing the filter
      object with new parameters).

      Attributes required in self:
      vehicle_types: [list] of vehicle type IDs as strings or
          eflips.depot.simple_vehicle.VehicleType objects


   .. py:method:: filter_trip_vehicle_match(vehicle)

      Return True if vehicle is suitable for self.trip (for vehicles that
      have not entered the system yet) or if vehicle and self.trip were
      matched by the dispatching.

      Attributes required in self:
      trip: eflips.depot.standalone.SimpleTrip object


   .. py:method:: filter_no_active_processes(vehicle)
      :staticmethod:

      Return True if the vehicle has no active processes.


   .. py:method:: filter_no_active_uncancellable_processes(vehicle)
      :staticmethod:

      Return True if the vehicle has no active processes or only those
      that can be cancelled for dispatch.


   .. py:method:: filter_bat_full(vehicle)
      :staticmethod:

      Return True if the vehicle's battery is full.


   .. py:method:: filter_min_energy(vehicle)

      Return True if the remaining energy of the vehicle's battery is at
      least self.min_energy.

      Attributes required in self:
      min_energy: [int] minimum battery level


   .. py:method:: filter_sufficient_energy(vehicle)

      Return True if the remaining energy of the vehicle's battery plus a
      reserve is sufficient for the trip.

      Attributes required in self:
      trip: eflips.depot.standalone.SimpleTrip object


   .. py:method:: filter_soc_lower_than(vehicle)

      Return True if the soc of the vehicle's battery is lower than
      self.soc.

      Attributes required in self:
      soc: [float]


   .. py:method:: filter_service_need(vehicle)

      Return True if the vehicle needs service, i.e. the cumulated trip
      time since last service is greater than self.service_need_td or the
      elapsed time since last service is greater than
      self.service_need_t_elapsed.
      This filter is one option to check the service need. An independent
      alternative is filter_in_period.

      Attributes required in self:
      env: simpy.Environment object
      service_need_td: [int] amount of driving time [seconds] since last
        service from which service_need will be set to True when exceeded.
      service_need_t_elapsed: [int] amount of elapsed time [seconds] since
          last service from which service_need will be set to True when
          exceeded.


   .. py:method:: filter_repair_need(vehicle)
      :staticmethod:

      Return True if the vehicle needs repair.


   .. py:method:: filter_maintenance_need(vehicle)
      :staticmethod:

      Return True if the vehicle needs maintenance.


   .. py:method:: filter_in_period(vehicle)

      Return True if self.now as a daytime is in self.period.

      Attributes required in self:
      env: simpy.Environment object
      period: [tuple or list] daytime period (t0, t1) for
          filter_in_period. t0 and t1 are seconds with 0 < t < 86400. t1 may
          be lower than t0 to specify periods including midnight. t0 and t1
          cannot be equal. (reason for list is enabling direct json input)


   .. py:method:: filter_in_period_days(vehicle)

      Return True if the time is in period and it is the third, fourth,
      ... day.

      Attributes required in self:
      env: simpy.Environment object
      after_day: [int] determines in how many days a service has to be
          done. For example every third day.


   .. py:method:: filter_isunblocked(vehicle)
      :staticmethod:


   .. py:method:: filter_not_on_hold(vehicle)
      :staticmethod:

      Return True if *vehicle* is not marked to be on hold.


   .. py:method:: filter_dwd_previous_area(vehicle)

      Check if current area is in none_of_previous_areas.

      Attributes required in self:
      none_of_previous_areas: [list] Skip current area if previous
          area in none_of_previous_areas.


   .. py:method:: filter_false(vehicle)
      :staticmethod:

      Always return False.



