:py:mod:`depot.layout_opt.evaluation`
=====================================

.. py:module:: depot.layout_opt.evaluation


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   depot.layout_opt.evaluation.OptEvaluation



Functions
~~~~~~~~~

.. autoapisummary::

   depot.layout_opt.evaluation.now_repr
   depot.layout_opt.evaluation.load
   depot.layout_opt.evaluation.running_mean



.. py:class:: OptEvaluation(pop, logbook, hof, crossovers, mutations, memory, feasible, feasible_fr_vec)


   Container and tools for evaluation.

   feasible: [function] that returns the feasiblity of an individual.
   feasible_fr_vec: [function] that returns a feasibility vector of an
       individual from its results.

   .. py:method:: _count_fitnesses()

      Gather fitness and feasibility data.


   .. py:method:: results_operators()


   .. py:method:: results_simtimes()


   .. py:method:: results_feasbility()


   .. py:method:: progress_so(objective_label='Kapazit채t')

      Progress of the objective value for depot layout optimization with a
       single objective.

      objective_label: axis label for the objective


   .. py:method:: progress_c_d_j(objectives_labels=('Kapazit채t', 'Versp채tung [h]', 'Stau [h]'), objectives_names=('c', 'd', 'j'), show=True, save=False, formats=('pdf', ), basefilename='progress_c_d_j')

      Plots for the progress of the objectives values for depot layout
      optimization with objectives c, d and j. Time unit is hours.


   .. py:method:: progress_c_urfd(objectives_labels=('Kapazit채t', 'Unblocked ready for departure vehicles'), objectives_names=('c', 'urfd'), show=True, save=False, formats=('pdf', ), basefilename='progress_c_urfd')

      Plots for the progress of the objectives values for depot layout
      optimization with objectives c and urfd.


   .. py:method:: progress_mo(objectives_labels, objectives_names, show=True, save=False, formats=('pdf', ), basefilename='progress_mo')

      Plots for the progress of the objectives values for depot layout
      optimization with multiple objectives.

      objectives_labels: iterable with axis labels for objectives
      objectives_names: iterable with names of objectives for the filename


   .. py:method:: objective_space_c_d_j(include_infeasible=True, show=True, save=False, formats=('pdf', ), basefilename='objective_space_c_d_j')

      Plot the objective space based on found fitnesses of depot layout
      optimization with objectives c, d, j. Fitnesses found multiple times
      are plotted only once.

      Time unit is hours.


   .. py:method:: pareto_front_c_d_j(include_infeasible=True, show=True, save=False, formats=('pdf', ), basefilename='pareto_front_c_d_j')

      Same as objective_space_c_d_j but only showing the pareto front.
      Time unit is hours.


   .. py:method:: objective_space_c_urfd(include_infeasible=True, show=True, save=False, formats=('pdf', ), basefilename='objective_space_c_urfd', xlim=('min', 'max'))

      Plot the objective space based on found fitnesses of depot layout
      optimization with objectives c and urfd. Fitnesses found multiple times
      are plotted only once.


   .. py:method:: pareto_front_c_urfd(include_infeasible=True, show=True, save=False, formats=('pdf', ), basefilename='pareto_front_c_urfd')

      Same as objective_space_c_urfd but only showing the pareto front.


   .. py:method:: comptime(show=True, save=False, formats=('pdf', ), basefilename='comptime', xlim=(0, 'max'))

      Computation time and number of lookups per generation. When
      multiprocessing was used, values still represent wall clock time, not
      computation time sum of worker processes.


   .. py:method:: ideas(show=True, save=False, formats=('pdf', ), basefilename='ideas', xlim=(0, 'max'))

      Number of individuals with new and looked up fitness by generation.


   .. py:method:: save(filename=None)


   .. py:method:: draw_hof(save=False, formats=('pdf', ), basefilename='hof')



.. py:function:: now_repr()

   Return the current system date and time as formatted string.


.. py:function:: load(filename)

   Load from pickle file.
   When loading OptEvaluation, the setup in the optimizing execution file must
   be run first so that classes such as Individual exist.

   filename: [str] including path, excluding extension


.. py:function:: running_mean(x, N)

   Calculate the running mean of *x*.
   From https://stackoverflow.com/a/27681394


